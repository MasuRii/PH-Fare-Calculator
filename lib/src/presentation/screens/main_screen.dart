import 'dart:async';

import 'package:flutter/material.dart';
import 'package:latlong2/latlong.dart';

import '../../core/di/injection.dart';
import '../../l10n/app_localizations.dart';
import '../../models/connectivity_status.dart';
import '../../models/fare_formula.dart';
import '../../repositories/fare_repository.dart';
import '../../services/connectivity/connectivity_service.dart';
import '../../services/fare_comparison_service.dart';
import '../../services/settings_service.dart';
import '../controllers/main_screen_controller.dart';
import '../widgets/main_screen/calculate_fare_button.dart';
import '../widgets/main_screen/error_message_banner.dart';
import '../widgets/main_screen/fare_results_header.dart';
import '../widgets/main_screen/fare_results_list.dart';
import '../widgets/main_screen/first_time_passenger_prompt.dart';
import '../widgets/main_screen/location_input_section.dart';
import '../widgets/main_screen/main_screen_app_bar.dart';
import '../widgets/main_screen/map_preview.dart';
import '../widgets/main_screen/offline_status_banner.dart';
import '../widgets/main_screen/passenger_bottom_sheet.dart';
import '../widgets/main_screen/transport_mode_selection_modal.dart';
import '../widgets/main_screen/travel_options_bar.dart';
import 'map_picker_screen.dart';

/// Main screen for the PH Fare Calculator app.
/// Refactored to use modular widgets and a controller for state management.
class MainScreen extends StatefulWidget {
  const MainScreen({super.key});

  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  late final MainScreenController _controller;
  late final ConnectivityService _connectivityService;
  late final SettingsService _settingsService;
  late final FareRepository _fareRepository;
  final TextEditingController _originTextController = TextEditingController();
  final TextEditingController _destinationTextController =
      TextEditingController();
  StreamSubscription<ConnectivityStatus>? _connectivitySubscription;
  ConnectivityStatus _connectivityStatus = ConnectivityStatus.online;

  /// Number of enabled transport modes (not hidden).
  int _enabledModesCount = 0;

  /// Total number of available transport modes.
  int _totalModesCount = 0;

  /// Cached list of all formulas for modal display.
  List<FareFormula> _allFormulas = [];

  @override
  void initState() {
    super.initState();
    _controller = MainScreenController();
    _connectivityService = getIt<ConnectivityService>();
    _settingsService = getIt<SettingsService>();
    _fareRepository = getIt<FareRepository>();
    _controller.addListener(_onControllerChanged);
    _initializeData();
    _initConnectivity();
    _loadTransportModeCounts();
  }

  Future<void> _initConnectivity() async {
    _connectivityStatus = _connectivityService.lastKnownStatus;
    _connectivitySubscription = _connectivityService.connectivityStream.listen((
      status,
    ) {
      if (mounted) {
        setState(() => _connectivityStatus = status);
      }
    });
  }

  /// Loads transport mode counts for the quick-access button badge.
  Future<void> _loadTransportModeCounts() async {
    try {
      final allFormulas = await _fareRepository.getAllFormulas();
      final hiddenModes = await _settingsService.getHiddenTransportModes();

      // Count unique mode-subtype combinations
      final allModeKeys = <String>{};
      for (final formula in allFormulas) {
        allModeKeys.add('${formula.mode}::${formula.subType}');
      }

      final enabledCount = allModeKeys
          .where((key) => !hiddenModes.contains(key))
          .length;

      if (mounted) {
        setState(() {
          _allFormulas = allFormulas;
          _totalModesCount = allModeKeys.length;
          _enabledModesCount = enabledCount;
        });
      }
    } catch (e) {
      // Silently handle error - the button will show 0/0
      debugPrint('Failed to load transport mode counts: $e');
    }
  }

  @override
  void dispose() {
    _connectivitySubscription?.cancel();
    _controller.removeListener(_onControllerChanged);
    _controller.dispose();
    _originTextController.dispose();
    _destinationTextController.dispose();
    super.dispose();
  }

  void _onControllerChanged() {
    if (mounted) {
      setState(() {});
      _syncTextControllers();
    }
  }

  void _syncTextControllers() {
    if (_controller.originLocation != null &&
        _originTextController.text != _controller.originLocation!.name) {
      _originTextController.text = _controller.originLocation!.name;
    }
    if (_controller.destinationLocation != null &&
        _destinationTextController.text !=
            _controller.destinationLocation!.name) {
      _destinationTextController.text = _controller.destinationLocation!.name;
    }
  }

  Future<void> _initializeData() async {
    await _controller.initialize();

    if (_controller.originLocation != null) {
      _originTextController.text = _controller.originLocation!.name;
    }

    final hasSetDiscountType = await _controller.hasSetDiscountType();
    if (!hasSetDiscountType && mounted) {
      _showFirstTimePassengerTypePrompt();
    }
  }

  Future<void> _showFirstTimePassengerTypePrompt() async {
    await Future.delayed(const Duration(milliseconds: 300));
    if (!mounted) return;

    await FirstTimePassengerPrompt.show(
      context: context,
      onDiscountTypeSelected: (discountType) async {
        await _controller.setUserDiscountType(discountType);
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      backgroundColor: colorScheme.surfaceContainerLowest,
      body: SafeArea(
        child: Column(
          children: [
            const MainScreenAppBar(),
            if (_connectivityStatus.isOffline || _connectivityStatus.isLimited)
              OfflineStatusBanner(status: _connectivityStatus),
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    const SizedBox(height: 8),
                    LocationInputSection(
                      originController: _originTextController,
                      destinationController: _destinationTextController,
                      isLoadingLocation: _controller.isLoadingLocation,
                      onSearchLocations: _controller.searchLocations,
                      onOriginSelected: _controller.setOriginLocation,
                      onDestinationSelected: _controller.setDestinationLocation,
                      onSwapLocations: _handleSwapLocations,
                      onUseCurrentLocation: _handleUseCurrentLocation,
                      onOpenMapPicker: _handleOpenMapPicker,
                    ),
                    const SizedBox(height: 16),
                    TravelOptionsBar(
                      regularPassengers: _controller.regularPassengers,
                      discountedPassengers: _controller.discountedPassengers,
                      sortCriteria: _controller.sortCriteria,
                      onPassengerTap: _showPassengerBottomSheet,
                      onSortChanged: _controller.setSortCriteria,
                      enabledModesCount: _enabledModesCount,
                      totalModesCount: _totalModesCount,
                      onTransportModesTap: _handleTransportModesTap,
                    ),
                    const SizedBox(height: 16),
                    // Map height: 280 when no fare results (40% larger), 200 when showing results
                    AnimatedContainer(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                      child: MapPreview(
                        origin: _controller.originLatLng,
                        destination: _controller.destinationLatLng,
                        routePoints: _controller.routePoints,
                        height: _controller.fareResults.isEmpty ? 280 : 200,
                      ),
                    ),
                    const SizedBox(height: 24),
                    CalculateFareButton(
                      canCalculate: _controller.canCalculate,
                      isCalculating: _controller.isCalculating,
                      onPressed: _handleCalculateFare,
                    ),
                    if (_controller.errorMessage != null) ...[
                      const SizedBox(height: 16),
                      ErrorMessageBanner(message: _controller.errorMessage!),
                    ],
                    if (_controller.fareResults.isNotEmpty) ...[
                      const SizedBox(height: 24),
                      FareResultsHeader(onSaveRoute: _handleSaveRoute),
                      const SizedBox(height: 16),
                      FareResultsList(
                        fareResults: _controller.fareResults,
                        sortCriteria: _controller.sortCriteria,
                        fareComparisonService: getIt<FareComparisonService>(),
                      ),
                    ],
                    const SizedBox(height: 24),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _handleSwapLocations() {
    final tempText = _originTextController.text;
    _originTextController.text = _destinationTextController.text;
    _destinationTextController.text = tempText;
    _controller.swapLocations();
  }

  Future<void> _handleUseCurrentLocation() async {
    try {
      final location = await _controller.getCurrentLocationAddress();
      _originTextController.text = location.name;
      _controller.setOriginLocation(location);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_controller.errorMessage ?? 'Failed to get location'),
            backgroundColor: Theme.of(context).colorScheme.error,
            duration: const Duration(seconds: 4),
          ),
        );
      }
    }
  }

  Future<void> _handleOpenMapPicker(bool isOrigin) async {
    final initialLocation = isOrigin
        ? _controller.originLatLng
        : (_controller.destinationLatLng ?? _controller.originLatLng);
    final title = isOrigin ? 'Select Origin' : 'Select Destination';

    final LatLng? selectedLatLng = await Navigator.push<LatLng>(
      context,
      MaterialPageRoute(
        builder: (context) =>
            MapPickerScreen(initialLocation: initialLocation, title: title),
      ),
    );

    if (selectedLatLng != null) {
      await _processMapPickerResult(selectedLatLng, isOrigin);
    }
  }

  Future<void> _processMapPickerResult(LatLng latLng, bool isOrigin) async {
    try {
      final location = await _controller.getAddressFromLatLng(
        latLng.latitude,
        latLng.longitude,
      );

      if (mounted) {
        if (isOrigin) {
          _originTextController.text = location.name;
          _controller.setOriginLocation(location);
        } else {
          _destinationTextController.text = location.name;
          _controller.setDestinationLocation(location);
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(_controller.errorMessage ?? 'Failed to get address'),
            backgroundColor: Theme.of(context).colorScheme.error,
            duration: const Duration(seconds: 4),
          ),
        );
      }
    }
  }

  Future<void> _showPassengerBottomSheet() async {
    await PassengerBottomSheet.show(
      context: context,
      initialRegular: _controller.regularPassengers,
      initialDiscounted: _controller.discountedPassengers,
      onApply: _controller.updatePassengers,
    );
  }

  Future<void> _handleSaveRoute() async {
    await _controller.saveRoute();
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(AppLocalizations.of(context)!.routeSavedMessage),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
        ),
      );
    }
  }

  /// Handles the transport modes quick-access button tap.
  /// Shows the transport mode selection modal and updates the count after.
  Future<void> _handleTransportModesTap() async {
    // Ensure we have formulas loaded
    if (_allFormulas.isEmpty) {
      await _loadTransportModeCounts();
    }

    if (!mounted || _allFormulas.isEmpty) return;

    await TransportModeSelectionModal.show(
      context: context,
      settingsService: _settingsService,
      availableFormulas: _allFormulas,
    );

    // Refresh the count after modal closes
    await _loadTransportModeCounts();
  }

  /// Handles fare calculation with transport mode check.
  /// If no transport modes are enabled, shows the mode selection modal first.
  Future<void> _handleCalculateFare() async {
    // Check if user has set transport mode preferences
    final hasSetPreferences = await _settingsService
        .hasSetTransportModePreferences();

    if (!hasSetPreferences) {
      // User hasn't set any preferences - show the modal
      final allFormulas = await _fareRepository.getAllFormulas();

      if (!mounted) return;

      final confirmed = await TransportModeSelectionModal.show(
        context: context,
        settingsService: _settingsService,
        availableFormulas: allFormulas,
      );

      // Refresh the count after modal closes
      await _loadTransportModeCounts();

      if (!confirmed) {
        // User cancelled - don't proceed with fare calculation
        return;
      }
    } else {
      // User has set preferences, check if any modes are actually enabled
      final hiddenModes = await _settingsService.getHiddenTransportModes();
      final allFormulas = await _fareRepository.getAllFormulas();

      // Check if ALL modes are hidden
      final allModesHidden = allFormulas.every((formula) {
        final modeSubTypeKey = '${formula.mode}::${formula.subType}';
        return hiddenModes.contains(modeSubTypeKey);
      });

      if (allModesHidden) {
        // All modes are hidden - show the modal
        if (!mounted) return;

        final confirmed = await TransportModeSelectionModal.show(
          context: context,
          settingsService: _settingsService,
          availableFormulas: allFormulas,
        );

        // Refresh the count after modal closes
        await _loadTransportModeCounts();

        if (!confirmed) {
          // User cancelled - don't proceed with fare calculation
          return;
        }
      }
    }

    // Proceed with fare calculation
    await _controller.calculateFare();
  }
}
